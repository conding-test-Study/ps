#답지 봄
# RDRD 함수가 주어진 문자열에서 R이 나올때마다 reverse를 하여 시간초과 발생
# reverse를 여러번 할때 짝수번 이면 안 뒤집고 홀수번이면 뒤집는데 
# RDD   DDR이랑 순서 바뀌면 다르니까 이렇게 처리하면 안 된다고 생각했던것 같다.
# 근데 R나올 때마다 몇번 나왔는지 기록해두고 D가 나오면 R 나온 횟수에 따라 뒤에서 뺴고 앞에서 뺴고 하는 그런 것이 가능하다는 생각을 못한것 같다.
# 가능한지 시뮬레이션을 해봐야했나? 비슷한 유형이 나오길...

#5430
#cmd가 RDDRDR 주어졌을때 R이 뒤집기고 D가 삭제인데
#뒤집기를 먼저 다 적용하고 D를 하면 결과가 다르다.
#삭제하고 뒤집기한거랑 뒤집기하고 삭제랑 순서가 바뀌면 결과가 다르다.

#이를 반영하면서 뒤집기를 매번하는게 아닌 짝수일때는 뒤집지않고
#홀수일때는 한번 뒤집는다. 그러면 삭제를 어떻게 할 것인가
#1 2 3 4 5한다고 했을때 뒤집기가 홀수인 상태에서는
#원래 순서에서 뒤집어진 상태에서 앞에서 삭제하는데 RDRD하면
#5를 삭제하고 다시 뒤집고 삭제하면 원래 순서 앞에 있던것을 지운다.
#뒤집든 말든 결국 삭제는 맨 앞 뒤에서 그대로 삭제하면된다.

#홀수면 뒤에서 짝수면 앞에서 삭제.
#그리고 if else할 때 elif로 해보리자.. else로 해버리니까 D말고 공백이 있던 경우 같이 삭제해버려서 시간을 많이 잡아먹음..

#일단 구현이라고 생각하고 문제를 풀었던 것같다.. 애초에 다른 유형이면 내가 풀수가 없다. 스택 큐등도 고려대상에 두고 시작했다.
#맨 앞 요소를 삭제하는 연산이 8만번 올 수 있으므로 이를 고려해야한다.
#전에 이런 문제를 본 적이 있다. 맨 앞요소 삭제할 때 배열로 하면 시간초과난 경험
#그리고 큐와 리스트인데 파이썬 리스트는 링크드 리스트랑 다르다.
#첫 요소 삭제하면 요소들을 모두 한칸 앞으로 옮겨야한다. 배열 형식으로 구현된것이다.
#큐는 앞에서 삭제할 때 맨 앞을 가리키는 포인터만 변경되는 식 링크드 리스트를 구현한것이다.



import sys
from collections import deque
input = sys.stdin.readline


T = int(input())
for tc in range(T):
    cmds = input()
    n = int(input())

    
    arr = input()[1:-2]
    arr = arr.split(",")

    q = deque(arr)
    if n == 0:
        q = deque()


    r = 0
    for cmd in cmds:
        err = False
        if cmd == "R":
            r += 1
        elif cmd == "D":
            if q:
                if r % 2 == 0:
                    q.popleft()
                else:
                    q.pop()
            else:
                print("error")
                err = True
                break

    if r % 2 != 0:
        q.reverse()
    if not err:
        print('[' + ",".join(q) + "]")
        


        
