#답지확인
#dp가 뭐였지부터 생각해서 배열에 이전 결과값들을 저장했던것 같은데  어떻게 저장하지?
#n의 계단 수 개수를 세는건데 n 이전의 결과값을 저장해서 구할 수가있나?
#n까지 정수가 많을텐데 이렇게 많은 배열을 저장한다고? 모르겠다..

#https://cotak.tistory.com/12
#길이가 N인 계단 수가 총 몇 개 있는지 구해보자 라고 문제에 나와서 길이가 1일때부터 N일때까지 
#길이를 기준으로 DP테이블을 만든건가    앞자리 따라서 그런건 계단수 유형?
# 0으로 시작하는 수는 계단수가 아니다. 라는 문장에서 시작하는 수 기준으로 DP테이블 되는건가

#dp테이블을 2차원으로 사용하는 것도 처음보고 
#자리 수가 몇 자리인지와    앞에 오는 숫자에 따라 
#경우의 수가 달라질 것이라는 걸 생각하지 못했다. 
#그저 많이 풀다가 비슷한 유형이 나오길.. 전에 답지 보고 넘어갔는데 기억이 안 난다.
#직접 한 번 풀어봐야지 기억에 좀 남는듯 하다. 그 때 풀었던 것 같은데 기억으로 풀어서 그런가

#0을 제외한 모든 숫자는 앞에 올 수 있다.
#이때 1~8은 뒤에 올 수 있는 숫자가 총 2종류이다(숫자±1).
#하지만 9 뒤엔 오직 숫자 8만이 올 수 있다.

#dp테이블은 이차원 리스트이며 dp[자리 수][앞에 오는 숫자]=경우의 수이다

#1자리수일 때 0~9가 맨 앞 올때 경우의 수 앞자
#2자리수일 때 0~9가 맨 앞 올때 경우의 수

N = int(input())

dp = [[0] * 10 for _ in range(N+1)]
for i in range(1,10):
    dp[1][i] = 1

for i in range(2,N+1):
    for j in range(10):
        if j == 0:
            dp[i][j] = dp[i-1][1]
        elif 1 <= j < 9:
            dp[i][j] = dp[i-1][j-1] + dp[i-1][j+1]
        else:
            dp[i][j] = dp[i-1][8]

print(sum(dp[N]) % 1000000000)
